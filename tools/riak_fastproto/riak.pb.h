// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak.proto

#ifndef PROTOBUF_riak_2eproto__INCLUDED
#define PROTOBUF_riak_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace riak_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_2eproto();
void protobuf_AssignDesc_riak_2eproto();
void protobuf_ShutdownFile_riak_2eproto();

class RpbErrorResp;
class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetServerInfoResp;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbGetBucketReq;
class RpbGetBucketResp;
class RpbSetBucketReq;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbContent;
class RpbPair;
class RpbLink;
class RpbBucketProps;

// ===================================================================

class RpbErrorResp : public ::google::protobuf::Message {
 public:
  RpbErrorResp();
  virtual ~RpbErrorResp();
  
  RpbErrorResp(const RpbErrorResp& from);
  
  inline RpbErrorResp& operator=(const RpbErrorResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbErrorResp& default_instance();
  
  void Swap(RpbErrorResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbErrorResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbErrorResp& from);
  void MergeFrom(const RpbErrorResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes errmsg = 1;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 1;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const void* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  
  // required uint32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbErrorResp)
 private:
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_errcode();
  inline void clear_has_errcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errmsg_;
  ::google::protobuf::uint32 errcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbErrorResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetClientIdResp : public ::google::protobuf::Message {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();
  
  RpbGetClientIdResp(const RpbGetClientIdResp& from);
  
  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetClientIdResp& default_instance();
  
  void Swap(RpbGetClientIdResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetClientIdResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetClientIdResp)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* client_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::Message {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();
  
  RpbSetClientIdReq(const RpbSetClientIdReq& from);
  
  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetClientIdReq& default_instance();
  
  void Swap(RpbSetClientIdReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetClientIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbSetClientIdReq)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* client_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetServerInfoResp : public ::google::protobuf::Message {
 public:
  RpbGetServerInfoResp();
  virtual ~RpbGetServerInfoResp();
  
  RpbGetServerInfoResp(const RpbGetServerInfoResp& from);
  
  inline RpbGetServerInfoResp& operator=(const RpbGetServerInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetServerInfoResp& default_instance();
  
  void Swap(RpbGetServerInfoResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetServerInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetServerInfoResp& from);
  void MergeFrom(const RpbGetServerInfoResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  
  // optional bytes server_version = 2;
  inline bool has_server_version() const;
  inline void clear_server_version();
  static const int kServerVersionFieldNumber = 2;
  inline const ::std::string& server_version() const;
  inline void set_server_version(const ::std::string& value);
  inline void set_server_version(const char* value);
  inline void set_server_version(const void* value, size_t size);
  inline ::std::string* mutable_server_version();
  inline ::std::string* release_server_version();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetServerInfoResp)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_server_version();
  inline void clear_has_server_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* node_;
  ::std::string* server_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetServerInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::Message {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();
  
  RpbGetReq(const RpbGetReq& from);
  
  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetReq& default_instance();
  
  void Swap(RpbGetReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);
  
  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);
  
  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);
  
  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);
  
  // optional bytes if_modified = 7;
  inline bool has_if_modified() const;
  inline void clear_if_modified();
  static const int kIfModifiedFieldNumber = 7;
  inline const ::std::string& if_modified() const;
  inline void set_if_modified(const ::std::string& value);
  inline void set_if_modified(const char* value);
  inline void set_if_modified(const void* value, size_t size);
  inline ::std::string* mutable_if_modified();
  inline ::std::string* release_if_modified();
  
  // optional bool head = 8;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 8;
  inline bool head() const;
  inline void set_head(bool value);
  
  // optional bool deletedvclock = 9;
  inline bool has_deletedvclock() const;
  inline void clear_deletedvclock();
  static const int kDeletedvclockFieldNumber = 9;
  inline bool deletedvclock() const;
  inline void set_deletedvclock(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_if_modified();
  inline void clear_has_if_modified();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_deletedvclock();
  inline void clear_has_deletedvclock();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::std::string* if_modified_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool head_;
  bool deletedvclock_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::Message {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();
  
  RpbGetResp(const RpbGetResp& from);
  
  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetResp& default_instance();
  
  void Swap(RpbGetResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .riak_proto.RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::riak_proto::RpbContent& content(int index) const;
  inline ::riak_proto::RpbContent* mutable_content(int index);
  inline ::riak_proto::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional bool unchanged = 3;
  inline bool has_unchanged() const;
  inline void clear_unchanged();
  static const int kUnchangedFieldNumber = 3;
  inline bool unchanged() const;
  inline void set_unchanged(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_unchanged();
  inline void clear_has_unchanged();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent > content_;
  ::std::string* vclock_;
  bool unchanged_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::Message {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();
  
  RpbPutReq(const RpbPutReq& from);
  
  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutReq& default_instance();
  
  void Swap(RpbPutReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // required .riak_proto.RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::riak_proto::RpbContent& content() const;
  inline ::riak_proto::RpbContent* mutable_content();
  inline ::riak_proto::RpbContent* release_content();
  
  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);
  
  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);
  
  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);
  
  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);
  
  // optional bool if_not_modified = 9;
  inline bool has_if_not_modified() const;
  inline void clear_if_not_modified();
  static const int kIfNotModifiedFieldNumber = 9;
  inline bool if_not_modified() const;
  inline void set_if_not_modified(bool value);
  
  // optional bool if_none_match = 10;
  inline bool has_if_none_match() const;
  inline void clear_if_none_match();
  static const int kIfNoneMatchFieldNumber = 10;
  inline bool if_none_match() const;
  inline void set_if_none_match(bool value);
  
  // optional bool return_head = 11;
  inline bool has_return_head() const;
  inline void clear_return_head();
  static const int kReturnHeadFieldNumber = 11;
  inline bool return_head() const;
  inline void set_return_head(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbPutReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_if_not_modified();
  inline void clear_has_if_not_modified();
  inline void set_has_if_none_match();
  inline void clear_has_if_none_match();
  inline void set_has_return_head();
  inline void clear_has_return_head();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::riak_proto::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool return_body_;
  bool if_not_modified_;
  bool if_none_match_;
  bool return_head_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::Message {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();
  
  RpbPutResp(const RpbPutResp& from);
  
  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutResp& default_instance();
  
  void Swap(RpbPutResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .riak_proto.RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::riak_proto::RpbContent& content(int index) const;
  inline ::riak_proto::RpbContent* mutable_content(int index);
  inline ::riak_proto::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >*
      mutable_content();
  
  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbPutResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_key();
  inline void clear_has_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent > content_;
  ::std::string* vclock_;
  ::std::string* key_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::Message {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();
  
  RpbDelReq(const RpbDelReq& from);
  
  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbDelReq& default_instance();
  
  void Swap(RpbDelReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);
  
  // optional bytes vclock = 4;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 4;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  
  // optional uint32 r = 5;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 5;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);
  
  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);
  
  // optional uint32 pr = 7;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 7;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);
  
  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);
  
  // optional uint32 dw = 9;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 9;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbDelReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_rw();
  inline void clear_has_rw();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_dw();
  inline void clear_has_dw();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 rw_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 dw_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::Message {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();
  
  RpbListBucketsResp(const RpbListBucketsResp& from);
  
  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsResp& default_instance();
  
  void Swap(RpbListBucketsResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListBucketsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbListBucketsResp)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::Message {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();
  
  RpbListKeysReq(const RpbListKeysReq& from);
  
  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysReq& default_instance();
  
  void Swap(RpbListKeysReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbListKeysReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::Message {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();
  
  RpbListKeysResp(const RpbListKeysResp& from);
  
  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysResp& default_instance();
  
  void Swap(RpbListKeysResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketReq();
  virtual ~RpbGetBucketReq();
  
  RpbGetBucketReq(const RpbGetBucketReq& from);
  
  inline RpbGetBucketReq& operator=(const RpbGetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketReq& default_instance();
  
  void Swap(RpbGetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketReq& from);
  void MergeFrom(const RpbGetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketResp();
  virtual ~RpbGetBucketResp();
  
  RpbGetBucketResp(const RpbGetBucketResp& from);
  
  inline RpbGetBucketResp& operator=(const RpbGetBucketResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketResp& default_instance();
  
  void Swap(RpbGetBucketResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbGetBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketResp& from);
  void MergeFrom(const RpbGetBucketResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .riak_proto.RpbBucketProps props = 1;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 1;
  inline const ::riak_proto::RpbBucketProps& props() const;
  inline ::riak_proto::RpbBucketProps* mutable_props();
  inline ::riak_proto::RpbBucketProps* release_props();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbGetBucketResp)
 private:
  inline void set_has_props();
  inline void clear_has_props();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::riak_proto::RpbBucketProps* props_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbGetBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetBucketReq : public ::google::protobuf::Message {
 public:
  RpbSetBucketReq();
  virtual ~RpbSetBucketReq();
  
  RpbSetBucketReq(const RpbSetBucketReq& from);
  
  inline RpbSetBucketReq& operator=(const RpbSetBucketReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetBucketReq& default_instance();
  
  void Swap(RpbSetBucketReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbSetBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetBucketReq& from);
  void MergeFrom(const RpbSetBucketReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // required .riak_proto.RpbBucketProps props = 2;
  inline bool has_props() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 2;
  inline const ::riak_proto::RpbBucketProps& props() const;
  inline ::riak_proto::RpbBucketProps* mutable_props();
  inline ::riak_proto::RpbBucketProps* release_props();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbSetBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_props();
  inline void clear_has_props();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::riak_proto::RpbBucketProps* props_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbSetBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::Message {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();
  
  RpbMapRedReq(const RpbMapRedReq& from);
  
  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedReq& default_instance();
  
  void Swap(RpbMapRedReq* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  
  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbMapRedReq)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_;
  ::std::string* content_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::Message {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();
  
  RpbMapRedResp(const RpbMapRedResp& from);
  
  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedResp& default_instance();
  
  void Swap(RpbMapRedResp* other);
  
  // implements Message ----------------------------------------------
  
  RpbMapRedResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);
  
  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbMapRedResp)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_done();
  inline void clear_has_done();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_;
  ::google::protobuf::uint32 phase_;
  bool done_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::Message {
 public:
  RpbContent();
  virtual ~RpbContent();
  
  RpbContent(const RpbContent& from);
  
  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbContent& default_instance();
  
  void Swap(RpbContent* other);
  
  // implements Message ----------------------------------------------
  
  RpbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  
  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  
  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  inline ::std::string* release_content_encoding();
  
  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  inline ::std::string* release_vtag();
  
  // repeated .riak_proto.RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::riak_proto::RpbLink& links(int index) const;
  inline ::riak_proto::RpbLink* mutable_links(int index);
  inline ::riak_proto::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbLink >*
      mutable_links();
  
  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);
  
  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);
  
  // repeated .riak_proto.RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::riak_proto::RpbPair& usermeta(int index) const;
  inline ::riak_proto::RpbPair* mutable_usermeta(int index);
  inline ::riak_proto::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbPair >*
      mutable_usermeta();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbContent)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_content_encoding();
  inline void clear_has_content_encoding();
  inline void set_has_vtag();
  inline void clear_has_vtag();
  inline void set_has_last_mod();
  inline void clear_has_last_mod();
  inline void set_has_last_mod_usecs();
  inline void clear_has_last_mod_usecs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::std::string* content_type_;
  ::std::string* charset_;
  ::std::string* content_encoding_;
  ::std::string* vtag_;
  ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbPair > usermeta_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbPair : public ::google::protobuf::Message {
 public:
  RpbPair();
  virtual ~RpbPair();
  
  RpbPair(const RpbPair& from);
  
  inline RpbPair& operator=(const RpbPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPair& default_instance();
  
  void Swap(RpbPair* other);
  
  // implements Message ----------------------------------------------
  
  RpbPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPair& from);
  void MergeFrom(const RpbPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbPair* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::Message {
 public:
  RpbLink();
  virtual ~RpbLink();
  
  RpbLink(const RpbLink& from);
  
  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbLink& default_instance();
  
  void Swap(RpbLink* other);
  
  // implements Message ----------------------------------------------
  
  RpbLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  
  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbLink)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketProps : public ::google::protobuf::Message {
 public:
  RpbBucketProps();
  virtual ~RpbBucketProps();
  
  RpbBucketProps(const RpbBucketProps& from);
  
  inline RpbBucketProps& operator=(const RpbBucketProps& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketProps& default_instance();
  
  void Swap(RpbBucketProps* other);
  
  // implements Message ----------------------------------------------
  
  RpbBucketProps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketProps& from);
  void MergeFrom(const RpbBucketProps& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 n_val = 1;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 1;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);
  
  // optional bool allow_mult = 2;
  inline bool has_allow_mult() const;
  inline void clear_allow_mult();
  static const int kAllowMultFieldNumber = 2;
  inline bool allow_mult() const;
  inline void set_allow_mult(bool value);
  
  // @@protoc_insertion_point(class_scope:riak_proto.RpbBucketProps)
 private:
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_allow_mult();
  inline void clear_has_allow_mult();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 n_val_;
  bool allow_mult_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_riak_2eproto();
  friend void protobuf_AssignDesc_riak_2eproto();
  friend void protobuf_ShutdownFile_riak_2eproto();
  
  void InitAsDefaultInstance();
  static RpbBucketProps* default_instance_;
};
// ===================================================================


// ===================================================================

// RpbErrorResp

// required bytes errmsg = 1;
inline bool RpbErrorResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbErrorResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbErrorResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbErrorResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& RpbErrorResp::errmsg() const {
  return *errmsg_;
}
inline void RpbErrorResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void RpbErrorResp::set_errmsg(const void* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbErrorResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* RpbErrorResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 errcode = 2;
inline bool RpbErrorResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbErrorResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbErrorResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbErrorResp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 RpbErrorResp::errcode() const {
  return errcode_;
}
inline void RpbErrorResp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
}

// -------------------------------------------------------------------

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetClientIdResp::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetClientIdResp::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbGetClientIdResp::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetClientIdReq::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetClientIdReq::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* RpbSetClientIdReq::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetServerInfoResp

// optional bytes node = 1;
inline bool RpbGetServerInfoResp::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetServerInfoResp::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetServerInfoResp::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetServerInfoResp::clear_node() {
  if (node_ != &::google::protobuf::internal::kEmptyString) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RpbGetServerInfoResp::node() const {
  return *node_;
}
inline void RpbGetServerInfoResp::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void RpbGetServerInfoResp::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    node_ = new ::std::string;
  }
  return node_;
}
inline ::std::string* RpbGetServerInfoResp::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes server_version = 2;
inline bool RpbGetServerInfoResp::has_server_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetServerInfoResp::set_has_server_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetServerInfoResp::clear_has_server_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetServerInfoResp::clear_server_version() {
  if (server_version_ != &::google::protobuf::internal::kEmptyString) {
    server_version_->clear();
  }
  clear_has_server_version();
}
inline const ::std::string& RpbGetServerInfoResp::server_version() const {
  return *server_version_;
}
inline void RpbGetServerInfoResp::set_server_version(const ::std::string& value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const char* value) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(value);
}
inline void RpbGetServerInfoResp::set_server_version(const void* value, size_t size) {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  server_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetServerInfoResp::mutable_server_version() {
  set_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    server_version_ = new ::std::string;
  }
  return server_version_;
}
inline ::std::string* RpbGetServerInfoResp::release_server_version() {
  clear_has_server_version();
  if (server_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_version_;
    server_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetReq::bucket() const {
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetReq::key() const {
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
}

// optional uint32 pr = 4;
inline bool RpbGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbGetReq::pr() const {
  return pr_;
}
inline void RpbGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
}

// optional bool basic_quorum = 5;
inline bool RpbGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbGetReq::basic_quorum() const {
  return basic_quorum_;
}
inline void RpbGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
}

// optional bool notfound_ok = 6;
inline bool RpbGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbGetReq::notfound_ok() const {
  return notfound_ok_;
}
inline void RpbGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
}

// optional bytes if_modified = 7;
inline bool RpbGetReq::has_if_modified() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbGetReq::set_has_if_modified() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbGetReq::clear_has_if_modified() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbGetReq::clear_if_modified() {
  if (if_modified_ != &::google::protobuf::internal::kEmptyString) {
    if_modified_->clear();
  }
  clear_has_if_modified();
}
inline const ::std::string& RpbGetReq::if_modified() const {
  return *if_modified_;
}
inline void RpbGetReq::set_if_modified(const ::std::string& value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
}
inline void RpbGetReq::set_if_modified(const char* value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
}
inline void RpbGetReq::set_if_modified(const void* value, size_t size) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetReq::mutable_if_modified() {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    if_modified_ = new ::std::string;
  }
  return if_modified_;
}
inline ::std::string* RpbGetReq::release_if_modified() {
  clear_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = if_modified_;
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool head = 8;
inline bool RpbGetReq::has_head() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbGetReq::set_has_head() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbGetReq::clear_has_head() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbGetReq::clear_head() {
  head_ = false;
  clear_has_head();
}
inline bool RpbGetReq::head() const {
  return head_;
}
inline void RpbGetReq::set_head(bool value) {
  set_has_head();
  head_ = value;
}

// optional bool deletedvclock = 9;
inline bool RpbGetReq::has_deletedvclock() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbGetReq::set_has_deletedvclock() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbGetReq::clear_has_deletedvclock() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbGetReq::clear_deletedvclock() {
  deletedvclock_ = false;
  clear_has_deletedvclock();
}
inline bool RpbGetReq::deletedvclock() const {
  return deletedvclock_;
}
inline void RpbGetReq::set_deletedvclock(bool value) {
  set_has_deletedvclock();
  deletedvclock_ = value;
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .riak_proto.RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::riak_proto::RpbContent& RpbGetResp::content(int index) const {
  return content_.Get(index);
}
inline ::riak_proto::RpbContent* RpbGetResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::riak_proto::RpbContent* RpbGetResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >&
RpbGetResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >*
RpbGetResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbGetResp::vclock() const {
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbGetResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool unchanged = 3;
inline bool RpbGetResp::has_unchanged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetResp::set_has_unchanged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetResp::clear_has_unchanged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetResp::clear_unchanged() {
  unchanged_ = false;
  clear_has_unchanged();
}
inline bool RpbGetResp::unchanged() const {
  return unchanged_;
}
inline void RpbGetResp::set_unchanged(bool value) {
  set_has_unchanged();
  unchanged_ = value;
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPutReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPutReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbPutReq::bucket() const {
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbPutReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutReq::key() const {
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPutReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutReq::vclock() const {
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .riak_proto.RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbPutReq::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbPutReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::riak_proto::RpbContent::Clear();
  clear_has_content();
}
inline const ::riak_proto::RpbContent& RpbPutReq::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::riak_proto::RpbContent* RpbPutReq::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::riak_proto::RpbContent;
  return content_;
}
inline ::riak_proto::RpbContent* RpbPutReq::release_content() {
  clear_has_content();
  ::riak_proto::RpbContent* temp = content_;
  content_ = NULL;
  return temp;
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbPutReq::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbPutReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbPutReq::set_has_dw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbPutReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbPutReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbPutReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbPutReq::return_body() const {
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
}

// optional uint32 pw = 8;
inline bool RpbPutReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbPutReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbPutReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbPutReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbPutReq::pw() const {
  return pw_;
}
inline void RpbPutReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
}

// optional bool if_not_modified = 9;
inline bool RpbPutReq::has_if_not_modified() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbPutReq::set_has_if_not_modified() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbPutReq::clear_has_if_not_modified() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbPutReq::clear_if_not_modified() {
  if_not_modified_ = false;
  clear_has_if_not_modified();
}
inline bool RpbPutReq::if_not_modified() const {
  return if_not_modified_;
}
inline void RpbPutReq::set_if_not_modified(bool value) {
  set_has_if_not_modified();
  if_not_modified_ = value;
}

// optional bool if_none_match = 10;
inline bool RpbPutReq::has_if_none_match() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbPutReq::set_has_if_none_match() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbPutReq::clear_has_if_none_match() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbPutReq::clear_if_none_match() {
  if_none_match_ = false;
  clear_has_if_none_match();
}
inline bool RpbPutReq::if_none_match() const {
  return if_none_match_;
}
inline void RpbPutReq::set_if_none_match(bool value) {
  set_has_if_none_match();
  if_none_match_ = value;
}

// optional bool return_head = 11;
inline bool RpbPutReq::has_return_head() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbPutReq::set_has_return_head() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbPutReq::clear_has_return_head() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbPutReq::clear_return_head() {
  return_head_ = false;
  clear_has_return_head();
}
inline bool RpbPutReq::return_head() const {
  return return_head_;
}
inline void RpbPutReq::set_return_head(bool value) {
  set_has_return_head();
  return_head_ = value;
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .riak_proto.RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::riak_proto::RpbContent& RpbPutResp::content(int index) const {
  return content_.Get(index);
}
inline ::riak_proto::RpbContent* RpbPutResp::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::riak_proto::RpbContent* RpbPutResp::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >&
RpbPutResp::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbContent >*
RpbPutResp::mutable_content() {
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutResp::vclock() const {
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbPutResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 3;
inline bool RpbPutResp::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutResp::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutResp::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutResp::key() const {
  return *key_;
}
inline void RpbPutResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPutResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPutResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPutResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbDelReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbDelReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbDelReq::bucket() const {
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbDelReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbDelReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbDelReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbDelReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbDelReq::key() const {
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbDelReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbDelReq::set_has_rw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbDelReq::clear_has_rw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
}

// optional bytes vclock = 4;
inline bool RpbDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::kEmptyString) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbDelReq::vclock() const {
  return *vclock_;
}
inline void RpbDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
}
inline void RpbDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    vclock_ = new ::std::string;
  }
  return vclock_;
}
inline ::std::string* RpbDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 r = 5;
inline bool RpbDelReq::has_r() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbDelReq::set_has_r() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbDelReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbDelReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbDelReq::r() const {
  return r_;
}
inline void RpbDelReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
}

// optional uint32 w = 6;
inline bool RpbDelReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbDelReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbDelReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbDelReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbDelReq::w() const {
  return w_;
}
inline void RpbDelReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
}

// optional uint32 pr = 7;
inline bool RpbDelReq::has_pr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbDelReq::set_has_pr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbDelReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbDelReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbDelReq::pr() const {
  return pr_;
}
inline void RpbDelReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
}

// optional uint32 pw = 8;
inline bool RpbDelReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbDelReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbDelReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbDelReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbDelReq::pw() const {
  return pw_;
}
inline void RpbDelReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
}

// optional uint32 dw = 9;
inline bool RpbDelReq::has_dw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbDelReq::set_has_dw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbDelReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbDelReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbDelReq::dw() const {
  return dw_;
}
inline void RpbDelReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  return &buckets_;
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListKeysReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListKeysReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbListKeysReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListKeysResp::done() const {
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbGetBucketReq

// required bytes bucket = 1;
inline bool RpbGetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbGetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbGetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbGetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbGetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbGetBucketResp

// required .riak_proto.RpbBucketProps props = 1;
inline bool RpbGetBucketResp::has_props() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketResp::set_has_props() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketResp::clear_has_props() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketResp::clear_props() {
  if (props_ != NULL) props_->::riak_proto::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::riak_proto::RpbBucketProps& RpbGetBucketResp::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::riak_proto::RpbBucketProps* RpbGetBucketResp::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::riak_proto::RpbBucketProps;
  return props_;
}
inline ::riak_proto::RpbBucketProps* RpbGetBucketResp::release_props() {
  clear_has_props();
  ::riak_proto::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbSetBucketReq

// required bytes bucket = 1;
inline bool RpbSetBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbSetBucketReq::bucket() const {
  return *bucket_;
}
inline void RpbSetBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbSetBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbSetBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbSetBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .riak_proto.RpbBucketProps props = 2;
inline bool RpbSetBucketReq::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbSetBucketReq::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbSetBucketReq::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbSetBucketReq::clear_props() {
  if (props_ != NULL) props_->::riak_proto::RpbBucketProps::Clear();
  clear_has_props();
}
inline const ::riak_proto::RpbBucketProps& RpbSetBucketReq::props() const {
  return props_ != NULL ? *props_ : *default_instance_->props_;
}
inline ::riak_proto::RpbBucketProps* RpbSetBucketReq::mutable_props() {
  set_has_props();
  if (props_ == NULL) props_ = new ::riak_proto::RpbBucketProps;
  return props_;
}
inline ::riak_proto::RpbBucketProps* RpbSetBucketReq::release_props() {
  clear_has_props();
  ::riak_proto::RpbBucketProps* temp = props_;
  props_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedReq::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedReq::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& RpbMapRedReq::request() const {
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* RpbMapRedReq::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedReq::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedReq::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbMapRedReq::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedResp::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedResp::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  clear_has_phase();
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  set_has_phase();
  phase_ = value;
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedResp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedResp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& RpbMapRedResp::response() const {
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* RpbMapRedResp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbMapRedResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbMapRedResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbMapRedResp::done() const {
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  set_has_done();
  done_ = value;
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbContent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbContent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbContent::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbContent::value() const {
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbContent::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RpbContent::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbContent::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbContent::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::kEmptyString) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbContent::content_type() const {
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    content_type_ = new ::std::string;
  }
  return content_type_;
}
inline ::std::string* RpbContent::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbContent::set_has_charset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbContent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbContent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RpbContent::charset() const {
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* RpbContent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbContent::set_has_content_encoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbContent::clear_has_content_encoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &::google::protobuf::internal::kEmptyString) {
    content_encoding_->clear();
  }
  clear_has_content_encoding();
}
inline const ::std::string& RpbContent::content_encoding() const {
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const char* value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    content_encoding_ = new ::std::string;
  }
  return content_encoding_;
}
inline ::std::string* RpbContent::release_content_encoding() {
  clear_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_encoding_;
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbContent::set_has_vtag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbContent::clear_has_vtag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &::google::protobuf::internal::kEmptyString) {
    vtag_->clear();
  }
  clear_has_vtag();
}
inline const ::std::string& RpbContent::vtag() const {
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const char* value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbContent::mutable_vtag() {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    vtag_ = new ::std::string;
  }
  return vtag_;
}
inline ::std::string* RpbContent::release_vtag() {
  clear_has_vtag();
  if (vtag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vtag_;
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .riak_proto.RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::riak_proto::RpbLink& RpbContent::links(int index) const {
  return links_.Get(index);
}
inline ::riak_proto::RpbLink* RpbContent::mutable_links(int index) {
  return links_.Mutable(index);
}
inline ::riak_proto::RpbLink* RpbContent::add_links() {
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbLink >&
RpbContent::links() const {
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbLink >*
RpbContent::mutable_links() {
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbContent::set_has_last_mod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbContent::clear_has_last_mod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  clear_has_last_mod();
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  set_has_last_mod();
  last_mod_ = value;
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbContent::set_has_last_mod_usecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbContent::clear_has_last_mod_usecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  clear_has_last_mod_usecs();
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  set_has_last_mod_usecs();
  last_mod_usecs_ = value;
}

// repeated .riak_proto.RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::riak_proto::RpbPair& RpbContent::usermeta(int index) const {
  return usermeta_.Get(index);
}
inline ::riak_proto::RpbPair* RpbContent::mutable_usermeta(int index) {
  return usermeta_.Mutable(index);
}
inline ::riak_proto::RpbPair* RpbContent::add_usermeta() {
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbPair >&
RpbContent::usermeta() const {
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::riak_proto::RpbPair >*
RpbContent::mutable_usermeta() {
  return &usermeta_;
}

// -------------------------------------------------------------------

// RpbPair

// required bytes key = 1;
inline bool RpbPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPair::key() const {
  return *key_;
}
inline void RpbPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbPair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes value = 2;
inline bool RpbPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbPair::value() const {
  return *value_;
}
inline void RpbPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RpbPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RpbPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbLink::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbLink::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbLink::bucket() const {
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* RpbLink::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbLink::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbLink::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbLink::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbLink::key() const {
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RpbLink::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RpbLink::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbLink::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbLink::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbLink::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& RpbLink::tag() const {
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpbLink::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* RpbLink::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RpbBucketProps

// optional uint32 n_val = 1;
inline bool RpbBucketProps::has_n_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketProps::set_has_n_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketProps::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketProps::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbBucketProps::n_val() const {
  return n_val_;
}
inline void RpbBucketProps::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
}

// optional bool allow_mult = 2;
inline bool RpbBucketProps::has_allow_mult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketProps::set_has_allow_mult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketProps::clear_has_allow_mult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketProps::clear_allow_mult() {
  allow_mult_ = false;
  clear_has_allow_mult();
}
inline bool RpbBucketProps::allow_mult() const {
  return allow_mult_;
}
inline void RpbBucketProps::set_allow_mult(bool value) {
  set_has_allow_mult();
  allow_mult_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace riak_proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_2eproto__INCLUDED
